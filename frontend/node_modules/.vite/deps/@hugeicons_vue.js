import {
  Fragment,
  computed,
  createBlock,
  createElementBlock,
  defineComponent,
  mergeProps,
  openBlock,
  renderList,
  resolveDynamicComponent
} from "./chunk-4EPKHDIW.js";
import "./chunk-BUSYA2B4.js";

// node_modules/@hugeicons/vue/dist/esm/components/HugeiconsIcon.vue2.js
var _sfc_main = defineComponent({
  name: "HugeiconsIcon",
  inheritAttrs: false,
  props: {
    icon: {
      type: Array,
      required: true
    },
    size: {
      type: [Number, String],
      default: 24,
      validator(value) {
        const size = typeof value === "string" ? parseInt(value, 10) : value;
        return !isNaN(size) && size > 0;
      }
    },
    strokeWidth: {
      type: Number,
      default: void 0
    },
    absoluteStrokeWidth: {
      type: Boolean,
      default: false
    },
    altIcon: {
      type: Array,
      default: void 0
    },
    showAlt: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: "currentColor"
    }
  },
  setup(props) {
    const computedSize = computed(() => {
      const size = typeof props.size === "string" ? parseInt(props.size, 10) : props.size;
      return !isNaN(size) && size > 0 ? size : 24;
    });
    const calculatedStrokeWidth = computed(() => {
      if (props.strokeWidth === void 0) return void 0;
      return props.absoluteStrokeWidth ? props.strokeWidth * 24 / computedSize.value : props.strokeWidth;
    });
    const currentIcon = computed(() => {
      return props.altIcon && props.showAlt ? props.altIcon : props.icon;
    });
    const transformAttrs = (attrs, strokeWidth) => {
      const result = {};
      for (const [key, value] of Object.entries(attrs)) {
        const kebabKey = key.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
        result[kebabKey] = value;
      }
      if (strokeWidth !== void 0) {
        result["stroke-width"] = strokeWidth;
        result["stroke"] = "currentColor";
      }
      return result;
    };
    return {
      computedSize,
      calculatedStrokeWidth,
      transformAttrs,
      currentIcon
    };
  }
});

// node_modules/@hugeicons/vue/dist/esm/_virtual/_plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// node_modules/@hugeicons/vue/dist/esm/components/HugeiconsIcon.vue.js
var _hoisted_1 = ["width", "height", "color"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: _ctx.computedSize,
    height: _ctx.computedSize,
    viewBox: `0 0 24 24`,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    color: _ctx.color
  }, _ctx.$attrs), [
    (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.currentIcon, (element, index) => {
        return openBlock(), createBlock(
          resolveDynamicComponent(element[0]),
          mergeProps({
            key: index,
            ref_for: true
          }, _ctx.transformAttrs(element[1], _ctx.calculatedStrokeWidth)),
          null,
          16
          /* FULL_PROPS */
        );
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ], 16, _hoisted_1);
}
var HugeiconsIcon = _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "/Users/mac/Documents/Projects/Hugeicons/monorepo/hugeicons/packages/vue/src/components/HugeiconsIcon.vue"]]);

// node_modules/@hugeicons/vue/dist/esm/index.js
var HugeiconsPlugin = {
  install: (app) => {
    app.component("HugeiconsIcon", HugeiconsIcon);
  }
};
export {
  HugeiconsIcon,
  HugeiconsPlugin,
  HugeiconsPlugin as default
};
//# sourceMappingURL=@hugeicons_vue.js.map
