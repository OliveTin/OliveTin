import {
  Code,
  ConnectError,
  appendHeaders,
  compressedFlag,
  contentTypeJson,
  contentTypeProto,
  createClientMethodSerializers,
  createContextValues,
  createEnvelopeReadableStream,
  createMethodUrl,
  encodeEnvelope,
  endStreamFlag,
  endStreamFromJson,
  errorFromJson,
  findTrailerError,
  fromJson,
  getJsonOptions,
  headerContentType,
  headerGrpcMessage,
  headerGrpcStatus,
  headerTimeout,
  headerUserAgent,
  headerXGrpcWeb,
  headerXUserAgent,
  requestHeader,
  runStreamingCall,
  runUnaryCall,
  trailerDemux,
  trailerFlag,
  trailerParse,
  transformConnectPostToGetRequest,
  validateResponse
} from "./chunk-QZHR2EEN.js";
import {
  MethodOptions_IdempotencyLevel
} from "./chunk-JBNGG26M.js";
import "./chunk-BUSYA2B4.js";

// node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js
function assertFetchApi() {
  try {
    new Headers();
  } catch (_) {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}

// node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var fetchOptions = {
  redirect: "error"
};
function createConnectTransport(options) {
  var _a;
  assertFetchApi();
  const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : false;
  return {
    async unary(method, signal, timeoutMs, header, message, contextValues) {
      const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);
      timeoutMs = timeoutMs === void 0 ? options.defaultTimeoutMs : timeoutMs <= 0 ? void 0 : timeoutMs;
      return await runUnaryCall({
        interceptors: options.interceptors,
        signal,
        timeoutMs,
        req: {
          stream: false,
          service: method.parent,
          method,
          requestMethod: "POST",
          url: createMethodUrl(options.baseUrl, method),
          header: requestHeader(method.methodKind, useBinaryFormat, timeoutMs, header, false),
          contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),
          message
        },
        next: async (req) => {
          var _a2;
          const useGet = options.useHttpGet === true && method.idempotency === MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;
          let body = null;
          if (useGet) {
            req = transformConnectPostToGetRequest(req, serialize(req.message), useBinaryFormat);
          } else {
            body = serialize(req.message);
          }
          const fetch = (_a2 = options.fetch) !== null && _a2 !== void 0 ? _a2 : globalThis.fetch;
          const response = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }));
          const { isUnaryError, unaryError } = validateResponse(method.methodKind, useBinaryFormat, response.status, response.headers);
          if (isUnaryError) {
            throw errorFromJson(await response.json(), appendHeaders(...trailerDemux(response.headers)), unaryError);
          }
          const [demuxedHeader, demuxedTrailer] = trailerDemux(response.headers);
          return {
            stream: false,
            service: method.parent,
            method,
            header: demuxedHeader,
            message: useBinaryFormat ? parse(new Uint8Array(await response.arrayBuffer())) : fromJson(method.output, await response.json(), getJsonOptions(options.jsonOptions)),
            trailer: demuxedTrailer
          };
        }
      });
    },
    async stream(method, signal, timeoutMs, header, input, contextValues) {
      const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);
      function parseResponseBody(body, trailerTarget, header2, signal2) {
        return __asyncGenerator(this, arguments, function* parseResponseBody_1() {
          const reader = createEnvelopeReadableStream(body).getReader();
          let endStreamReceived = false;
          for (; ; ) {
            const result = yield __await(reader.read());
            if (result.done) {
              break;
            }
            const { flags, data } = result.value;
            if ((flags & compressedFlag) === compressedFlag) {
              throw new ConnectError(`protocol error: received unsupported compressed output`, Code.Internal);
            }
            if ((flags & endStreamFlag) === endStreamFlag) {
              endStreamReceived = true;
              const endStream = endStreamFromJson(data);
              if (endStream.error) {
                const error = endStream.error;
                header2.forEach((value, key) => {
                  error.metadata.append(key, value);
                });
                throw error;
              }
              endStream.metadata.forEach((value, key) => trailerTarget.set(key, value));
              continue;
            }
            yield yield __await(parse(data));
          }
          if ("throwIfAborted" in signal2) {
            signal2.throwIfAborted();
          }
          if (!endStreamReceived) {
            throw "missing EndStreamResponse";
          }
        });
      }
      async function createRequestBody(input2) {
        if (method.methodKind != "server_streaming") {
          throw "The fetch API does not support streaming request bodies";
        }
        const r = await input2[Symbol.asyncIterator]().next();
        if (r.done == true) {
          throw "missing request message";
        }
        return encodeEnvelope(0, serialize(r.value));
      }
      timeoutMs = timeoutMs === void 0 ? options.defaultTimeoutMs : timeoutMs <= 0 ? void 0 : timeoutMs;
      return await runStreamingCall({
        interceptors: options.interceptors,
        timeoutMs,
        signal,
        req: {
          stream: true,
          service: method.parent,
          method,
          requestMethod: "POST",
          url: createMethodUrl(options.baseUrl, method),
          header: requestHeader(method.methodKind, useBinaryFormat, timeoutMs, header, false),
          contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),
          message: input
        },
        next: async (req) => {
          var _a2;
          const fetch = (_a2 = options.fetch) !== null && _a2 !== void 0 ? _a2 : globalThis.fetch;
          const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
          validateResponse(method.methodKind, useBinaryFormat, fRes.status, fRes.headers);
          if (fRes.body === null) {
            throw "missing response body";
          }
          const trailer = new Headers();
          const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, trailer, fRes.headers, req.signal) });
          return res;
        }
      });
    }
  };
}

// node_modules/@connectrpc/connect/dist/esm/protocol-grpc/validate-trailer.js
function validateTrailer(trailer, header) {
  const err = findTrailerError(trailer);
  if (err) {
    header.forEach((value, key) => {
      err.metadata.append(key, value);
    });
    throw err;
  }
  if (!header.has(headerGrpcStatus) && !trailer.has(headerGrpcStatus)) {
    throw new ConnectError("protocol error: missing status", Code.Internal);
  }
}

// node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/request-header.js
function requestHeader2(useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {
  var _a, _b;
  const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});
  result.set(headerContentType, useBinaryFormat ? contentTypeProto : contentTypeJson);
  result.set(headerXGrpcWeb, "1");
  const userAgent = (_b = (_a = result.get(headerUserAgent)) !== null && _a !== void 0 ? _a : result.get(headerXUserAgent)) !== null && _b !== void 0 ? _b : "connect-es/2.1.0";
  result.set(headerXUserAgent, userAgent);
  if (setUserAgent) {
    result.set(headerUserAgent, userAgent);
  }
  if (timeoutMs !== void 0) {
    result.set(headerTimeout, `${timeoutMs}m`);
  }
  return result;
}

// node_modules/@connectrpc/connect/dist/esm/protocol-grpc/http-status.js
function codeFromHttpStatus2(httpStatus) {
  switch (httpStatus) {
    case 400:
      return Code.Internal;
    case 401:
      return Code.Unauthenticated;
    case 403:
      return Code.PermissionDenied;
    case 404:
      return Code.Unimplemented;
    case 429:
      return Code.Unavailable;
    case 502:
      return Code.Unavailable;
    case 503:
      return Code.Unavailable;
    case 504:
      return Code.Unavailable;
    default:
      return Code.Unknown;
  }
}

// node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/validate-response.js
function validateResponse2(status, headers) {
  var _a;
  if (status >= 200 && status < 300) {
    return {
      foundStatus: headers.has(headerGrpcStatus),
      headerError: findTrailerError(headers)
    };
  }
  throw new ConnectError(decodeURIComponent((_a = headers.get(headerGrpcMessage)) !== null && _a !== void 0 ? _a : `HTTP ${status}`), codeFromHttpStatus2(status), headers);
}

// node_modules/@connectrpc/connect-web/dist/esm/grpc-web-transport.js
var __await2 = function(v) {
  return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
};
var __asyncGenerator2 = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var fetchOptions2 = {
  redirect: "error"
};
function createGrpcWebTransport(options) {
  var _a;
  assertFetchApi();
  const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : true;
  return {
    async unary(method, signal, timeoutMs, header, message, contextValues) {
      const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);
      timeoutMs = timeoutMs === void 0 ? options.defaultTimeoutMs : timeoutMs <= 0 ? void 0 : timeoutMs;
      return await runUnaryCall({
        interceptors: options.interceptors,
        signal,
        timeoutMs,
        req: {
          stream: false,
          service: method.parent,
          method,
          requestMethod: "POST",
          url: createMethodUrl(options.baseUrl, method),
          header: requestHeader2(useBinaryFormat, timeoutMs, header, false),
          contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),
          message
        },
        next: async (req) => {
          var _a2;
          const fetch = (_a2 = options.fetch) !== null && _a2 !== void 0 ? _a2 : globalThis.fetch;
          const response = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions2), { method: req.requestMethod, headers: req.header, signal: req.signal, body: encodeEnvelope(0, serialize(req.message)) }));
          const { headerError } = validateResponse2(response.status, response.headers);
          if (!response.body) {
            if (headerError !== void 0)
              throw headerError;
            throw "missing response body";
          }
          const reader = createEnvelopeReadableStream(response.body).getReader();
          let trailer;
          let message2;
          for (; ; ) {
            const r = await reader.read();
            if (r.done) {
              break;
            }
            const { flags, data } = r.value;
            if ((flags & compressedFlag) === compressedFlag) {
              throw new ConnectError(`protocol error: received unsupported compressed output`, Code.Internal);
            }
            if (flags === trailerFlag) {
              if (trailer !== void 0) {
                throw "extra trailer";
              }
              trailer = trailerParse(data);
              continue;
            }
            if (message2 !== void 0) {
              throw new ConnectError("extra message", Code.Unimplemented);
            }
            message2 = parse(data);
          }
          if (trailer === void 0) {
            if (headerError !== void 0)
              throw headerError;
            throw new ConnectError("missing trailer", response.headers.has(headerGrpcStatus) ? Code.Unimplemented : Code.Unknown);
          }
          validateTrailer(trailer, response.headers);
          if (message2 === void 0) {
            throw new ConnectError("missing message", trailer.has(headerGrpcStatus) ? Code.Unimplemented : Code.Unknown);
          }
          return {
            stream: false,
            service: method.parent,
            method,
            header: response.headers,
            message: message2,
            trailer
          };
        }
      });
    },
    async stream(method, signal, timeoutMs, header, input, contextValues) {
      const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);
      function parseResponseBody(body, foundStatus, trailerTarget, header2, signal2) {
        return __asyncGenerator2(this, arguments, function* parseResponseBody_1() {
          const reader = createEnvelopeReadableStream(body).getReader();
          if (foundStatus) {
            if (!(yield __await2(reader.read())).done) {
              throw "extra data for trailers-only";
            }
            return yield __await2(void 0);
          }
          let trailerReceived = false;
          for (; ; ) {
            const result = yield __await2(reader.read());
            if (result.done) {
              break;
            }
            const { flags, data } = result.value;
            if ((flags & trailerFlag) === trailerFlag) {
              if (trailerReceived) {
                throw "extra trailer";
              }
              trailerReceived = true;
              const trailer = trailerParse(data);
              validateTrailer(trailer, header2);
              trailer.forEach((value, key) => trailerTarget.set(key, value));
              continue;
            }
            if (trailerReceived) {
              throw "extra message";
            }
            yield yield __await2(parse(data));
          }
          if ("throwIfAborted" in signal2) {
            signal2.throwIfAborted();
          }
          if (!trailerReceived) {
            throw "missing trailer";
          }
        });
      }
      async function createRequestBody(input2) {
        if (method.methodKind != "server_streaming") {
          throw "The fetch API does not support streaming request bodies";
        }
        const r = await input2[Symbol.asyncIterator]().next();
        if (r.done == true) {
          throw "missing request message";
        }
        return encodeEnvelope(0, serialize(r.value));
      }
      timeoutMs = timeoutMs === void 0 ? options.defaultTimeoutMs : timeoutMs <= 0 ? void 0 : timeoutMs;
      return runStreamingCall({
        interceptors: options.interceptors,
        signal,
        timeoutMs,
        req: {
          stream: true,
          service: method.parent,
          method,
          requestMethod: "POST",
          url: createMethodUrl(options.baseUrl, method),
          header: requestHeader2(useBinaryFormat, timeoutMs, header, false),
          contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),
          message: input
        },
        next: async (req) => {
          var _a2;
          const fetch = (_a2 = options.fetch) !== null && _a2 !== void 0 ? _a2 : globalThis.fetch;
          const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions2), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
          const { foundStatus, headerError } = validateResponse2(fRes.status, fRes.headers);
          if (headerError != void 0) {
            throw headerError;
          }
          if (!fRes.body) {
            throw "missing response body";
          }
          const trailer = new Headers();
          const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, foundStatus, trailer, fRes.headers, req.signal) });
          return res;
        }
      });
    }
  };
}
export {
  createConnectTransport,
  createGrpcWebTransport
};
//# sourceMappingURL=@connectrpc_connect-web.js.map
