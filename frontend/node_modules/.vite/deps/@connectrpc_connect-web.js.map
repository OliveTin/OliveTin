{
  "version": 3,
  "sources": ["../../@connectrpc/connect-web/dist/esm/assert-fetch-api.js", "../../@connectrpc/connect-web/dist/esm/connect-transport.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/validate-trailer.js", "../../@connectrpc/connect/dist/esm/protocol-grpc-web/request-header.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/http-status.js", "../../@connectrpc/connect/dist/esm/protocol-grpc-web/validate-response.js", "../../@connectrpc/connect-web/dist/esm/grpc-web-transport.js"],
  "sourcesContent": ["// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Asserts that the fetch API is available.\n */\nexport function assertFetchApi() {\n    try {\n        new Headers();\n    }\n    catch (_) {\n        throw new Error(\"connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.\");\n    }\n}\n", "// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { fromJson } from \"@bufbuild/protobuf\";\nimport { Code, ConnectError, appendHeaders, createContextValues, } from \"@connectrpc/connect\";\nimport { createClientMethodSerializers, createEnvelopeReadableStream, createMethodUrl, getJsonOptions, encodeEnvelope, runStreamingCall, runUnaryCall, compressedFlag, } from \"@connectrpc/connect/protocol\";\nimport { endStreamFlag, endStreamFromJson, errorFromJson, requestHeader, trailerDemux, transformConnectPostToGetRequest, validateResponse, } from \"@connectrpc/connect/protocol-connect\";\nimport { assertFetchApi } from \"./assert-fetch-api.js\";\nimport { MethodOptions_IdempotencyLevel } from \"@bufbuild/protobuf/wkt\";\nconst fetchOptions = {\n    redirect: \"error\",\n};\n/**\n * Create a Transport for the Connect protocol, which makes unary and\n * server-streaming methods available to web browsers. It uses the fetch\n * API to make HTTP requests.\n */\nexport function createConnectTransport(options) {\n    var _a;\n    assertFetchApi();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : false;\n    return {\n        async unary(method, signal, timeoutMs, header, message, contextValues) {\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await runUnaryCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service: method.parent,\n                    method,\n                    requestMethod: \"POST\",\n                    url: createMethodUrl(options.baseUrl, method),\n                    header: requestHeader(method.methodKind, useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const useGet = options.useHttpGet === true &&\n                        method.idempotency ===\n                            MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;\n                    let body = null;\n                    if (useGet) {\n                        req = transformConnectPostToGetRequest(req, serialize(req.message), useBinaryFormat);\n                    }\n                    else {\n                        body = serialize(req.message);\n                    }\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }));\n                    const { isUnaryError, unaryError } = validateResponse(method.methodKind, useBinaryFormat, response.status, response.headers);\n                    if (isUnaryError) {\n                        throw errorFromJson((await response.json()), appendHeaders(...trailerDemux(response.headers)), unaryError);\n                    }\n                    const [demuxedHeader, demuxedTrailer] = trailerDemux(response.headers);\n                    return {\n                        stream: false,\n                        service: method.parent,\n                        method,\n                        header: demuxedHeader,\n                        message: useBinaryFormat\n                            ? parse(new Uint8Array(await response.arrayBuffer()))\n                            : fromJson(method.output, (await response.json()), getJsonOptions(options.jsonOptions)),\n                        trailer: demuxedTrailer,\n                    };\n                },\n            });\n        },\n        async stream(method, signal, timeoutMs, header, input, contextValues) {\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, trailerTarget, header, signal) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = createEnvelopeReadableStream(body).getReader();\n                    let endStreamReceived = false;\n                    for (;;) {\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & compressedFlag) === compressedFlag) {\n                            throw new ConnectError(`protocol error: received unsupported compressed output`, Code.Internal);\n                        }\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            endStreamReceived = true;\n                            const endStream = endStreamFromJson(data);\n                            if (endStream.error) {\n                                const error = endStream.error;\n                                header.forEach((value, key) => {\n                                    error.metadata.append(key, value);\n                                });\n                                throw error;\n                            }\n                            endStream.metadata.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        yield yield __await(parse(data));\n                    }\n                    // Node wil not throw an AbortError on `read` if the\n                    // signal is aborted before `getReader` is called.\n                    // As a work around we check at the end and throw.\n                    //\n                    // Ref: https://github.com/nodejs/undici/issues/1940\n                    if (\"throwIfAborted\" in signal) {\n                        // We assume that implementations without `throwIfAborted` (old\n                        // browsers) do honor aborted signals on `read`.\n                        signal.throwIfAborted();\n                    }\n                    if (!endStreamReceived) {\n                        throw \"missing EndStreamResponse\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.methodKind != \"server_streaming\") {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return encodeEnvelope(0, serialize(r.value));\n            }\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await runStreamingCall({\n                interceptors: options.interceptors,\n                timeoutMs,\n                signal,\n                req: {\n                    stream: true,\n                    service: method.parent,\n                    method,\n                    requestMethod: \"POST\",\n                    url: createMethodUrl(options.baseUrl, method),\n                    header: requestHeader(method.methodKind, useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    validateResponse(method.methodKind, useBinaryFormat, fRes.status, fRes.headers);\n                    if (fRes.body === null) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, trailer, fRes.headers, req.signal) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n", "// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { headerGrpcStatus } from \"./headers.js\";\nimport { findTrailerError } from \"./trailer-status.js\";\n/**\n * Validates a trailer for the gRPC and the gRPC-web protocol.\n *\n * If the trailer contains an error status, a ConnectError is\n * thrown. It will include trailer and header in the error's\n * \"metadata\" property.\n *\n * Throws a ConnectError with code \"internal\" if neither the trailer\n * nor the header contain the Grpc-Status field.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateTrailer(trailer, header) {\n    const err = findTrailerError(trailer);\n    if (err) {\n        header.forEach((value, key) => {\n            err.metadata.append(key, value);\n        });\n        throw err;\n    }\n    if (!header.has(headerGrpcStatus) && !trailer.has(headerGrpcStatus)) {\n        throw new ConnectError(\"protocol error: missing status\", Code.Internal);\n    }\n}\n", "// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { headerAcceptEncoding, headerContentType, headerEncoding, headerTimeout, headerXGrpcWeb, headerUserAgent, headerXUserAgent, } from \"./headers.js\";\nimport { contentTypeJson, contentTypeProto } from \"./content-type.js\";\n/**\n * Creates headers for a gRPC-web request.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {\n    var _a, _b;\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    // Note that we do not support the grpc-web-text format.\n    // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#protocol-differences-vs-grpc-over-http2\n    result.set(headerContentType, useBinaryFormat ? contentTypeProto : contentTypeJson);\n    result.set(headerXGrpcWeb, \"1\");\n    // Note that we do not strictly comply with gRPC user agents.\n    // We use \"connect-es/1.2.3\" where gRPC would use \"grpc-es/1.2.3\".\n    // See https://github.com/grpc/grpc/blob/c462bb8d485fc1434ecfae438823ca8d14cf3154/doc/PROTOCOL-HTTP2.md#user-agents\n    const userAgent = (_b = (_a = result.get(headerUserAgent)) !== null && _a !== void 0 ? _a : result.get(headerXUserAgent)) !== null && _b !== void 0 ? _b : \"connect-es/2.1.0\";\n    result.set(headerXUserAgent, userAgent);\n    if (setUserAgent) {\n        result.set(headerUserAgent, userAgent);\n    }\n    if (timeoutMs !== undefined) {\n        result.set(headerTimeout, `${timeoutMs}m`);\n    }\n    return result;\n}\n/**\n * Creates headers for a gRPC-web request with compression.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requestHeaderWithCompression(useBinaryFormat, timeoutMs, userProvidedHeaders, acceptCompression, sendCompression, setUserAgent) {\n    const result = requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent);\n    if (sendCompression != null) {\n        result.set(headerEncoding, sendCompression.name);\n    }\n    if (acceptCompression.length > 0) {\n        result.set(headerAcceptEncoding, acceptCompression.map((c) => c.name).join(\",\"));\n    }\n    return result;\n}\n", "// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\n/**\n * Determine the gRPC-web error code for the given HTTP status code.\n * See https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function codeFromHttpStatus(httpStatus) {\n    switch (httpStatus) {\n        case 400: // Bad Request\n            return Code.Internal;\n        case 401: // Unauthorized\n            return Code.Unauthenticated;\n        case 403: // Forbidden\n            return Code.PermissionDenied;\n        case 404: // Not Found\n            return Code.Unimplemented;\n        case 429: // Too Many Requests\n            return Code.Unavailable;\n        case 502: // Bad Gateway\n            return Code.Unavailable;\n        case 503: // Service Unavailable\n            return Code.Unavailable;\n        case 504: // Gateway Timeout\n            return Code.Unavailable;\n        default:\n            // 200 is UNKNOWN because there should be a grpc-status in case of truly OK response.\n            return Code.Unknown;\n    }\n}\n", "// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { headerEncoding, headerGrpcMessage, headerGrpcStatus, } from \"./headers.js\";\nimport { codeFromHttpStatus } from \"../protocol-grpc/http-status.js\";\nimport { findTrailerError } from \"../protocol-grpc/trailer-status.js\";\n/**\n * Validates response status and header for the gRPC-web protocol.\n *\n * Throws a ConnectError if the header contains an error status,\n * or if the HTTP status indicates an error.\n *\n * Returns an object that indicates whether a gRPC status was found\n * in the response header. In this case, clients can not expect a\n * trailer.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateResponse(status, headers) {\n    var _a;\n    // For compatibility with the `grpc-web` package, we treat all HTTP status\n    // codes in the 200 range as valid, not just HTTP 200.\n    if (status >= 200 && status < 300) {\n        return {\n            foundStatus: headers.has(headerGrpcStatus),\n            headerError: findTrailerError(headers),\n        };\n    }\n    throw new ConnectError(decodeURIComponent((_a = headers.get(headerGrpcMessage)) !== null && _a !== void 0 ? _a : `HTTP ${status}`), codeFromHttpStatus(status), headers);\n}\n/**\n * Validates response status and header for the gRPC-web protocol.\n * This function is identical to validateResponse(), but also verifies\n * that a given encoding header is acceptable.\n *\n * Returns an object with the response compression, and a boolean\n * indicating whether a gRPC status was found in the response header\n * (in this case, clients can not expect a trailer).\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateResponseWithCompression(acceptCompression, status, headers) {\n    const { foundStatus, headerError } = validateResponse(status, headers);\n    let compression;\n    const encoding = headers.get(headerEncoding);\n    if (encoding !== null && encoding.toLowerCase() !== \"identity\") {\n        compression = acceptCompression.find((c) => c.name === encoding);\n        if (!compression) {\n            throw new ConnectError(`unsupported response encoding \"${encoding}\"`, Code.Internal, headers);\n        }\n    }\n    return {\n        foundStatus,\n        compression,\n        headerError,\n    };\n}\n", "// Copyright 2021-2025 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { createContextValues, ConnectError, Code } from \"@connectrpc/connect\";\nimport { compressedFlag, createClientMethodSerializers, createEnvelopeReadableStream, createMethodUrl, encodeEnvelope, runStreamingCall, runUnaryCall, } from \"@connectrpc/connect/protocol\";\nimport { headerGrpcStatus, requestHeader, trailerFlag, trailerParse, validateResponse, validateTrailer, } from \"@connectrpc/connect/protocol-grpc-web\";\nimport { assertFetchApi } from \"./assert-fetch-api.js\";\nconst fetchOptions = {\n    redirect: \"error\",\n};\n/**\n * Create a Transport for the gRPC-web protocol. The protocol encodes\n * trailers in the response body and makes unary and server-streaming\n * methods available to web browsers. It uses the fetch API to make\n * HTTP requests.\n *\n * Note that this transport does not implement the grpc-web-text format,\n * which applies base64 encoding to the request and response bodies to\n * support reading streaming responses from an XMLHttpRequest.\n */\nexport function createGrpcWebTransport(options) {\n    var _a;\n    assertFetchApi();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : true;\n    return {\n        async unary(method, signal, timeoutMs, header, message, contextValues) {\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await runUnaryCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service: method.parent,\n                    method,\n                    requestMethod: \"POST\",\n                    url: createMethodUrl(options.baseUrl, method),\n                    header: requestHeader(useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: encodeEnvelope(0, serialize(req.message)) }));\n                    const { headerError } = validateResponse(response.status, response.headers);\n                    if (!response.body) {\n                        if (headerError !== undefined)\n                            throw headerError;\n                        throw \"missing response body\";\n                    }\n                    const reader = createEnvelopeReadableStream(response.body).getReader();\n                    let trailer;\n                    let message;\n                    for (;;) {\n                        const r = await reader.read();\n                        if (r.done) {\n                            break;\n                        }\n                        const { flags, data } = r.value;\n                        if ((flags & compressedFlag) === compressedFlag) {\n                            throw new ConnectError(`protocol error: received unsupported compressed output`, Code.Internal);\n                        }\n                        if (flags === trailerFlag) {\n                            if (trailer !== undefined) {\n                                throw \"extra trailer\";\n                            }\n                            // Unary responses require exactly one response message, but in\n                            // case of an error, it is perfectly valid to have a response body\n                            // that only contains error trailers.\n                            trailer = trailerParse(data);\n                            continue;\n                        }\n                        if (message !== undefined) {\n                            throw new ConnectError(\"extra message\", Code.Unimplemented);\n                        }\n                        message = parse(data);\n                    }\n                    if (trailer === undefined) {\n                        if (headerError !== undefined)\n                            throw headerError;\n                        throw new ConnectError(\"missing trailer\", response.headers.has(headerGrpcStatus)\n                            ? Code.Unimplemented\n                            : Code.Unknown);\n                    }\n                    validateTrailer(trailer, response.headers);\n                    if (message === undefined) {\n                        throw new ConnectError(\"missing message\", trailer.has(headerGrpcStatus) ? Code.Unimplemented : Code.Unknown);\n                    }\n                    return {\n                        stream: false,\n                        service: method.parent,\n                        method,\n                        header: response.headers,\n                        message,\n                        trailer,\n                    };\n                },\n            });\n        },\n        async stream(method, signal, timeoutMs, header, input, contextValues) {\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, foundStatus, trailerTarget, header, signal) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = createEnvelopeReadableStream(body).getReader();\n                    if (foundStatus) {\n                        // A grpc-status: 0 response header was present. This is a \"trailers-only\"\n                        // response (a response without a body and no trailers).\n                        //\n                        // The spec seems to disallow a trailers-only response for status 0 - we are\n                        // lenient and only verify that the body is empty.\n                        //\n                        // > [...] Trailers-Only is permitted for calls that produce an immediate error.\n                        // See https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\n                        if (!(yield __await(reader.read())).done) {\n                            throw \"extra data for trailers-only\";\n                        }\n                        return yield __await(void 0);\n                    }\n                    let trailerReceived = false;\n                    for (;;) {\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & trailerFlag) === trailerFlag) {\n                            if (trailerReceived) {\n                                throw \"extra trailer\";\n                            }\n                            trailerReceived = true;\n                            const trailer = trailerParse(data);\n                            validateTrailer(trailer, header);\n                            trailer.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        if (trailerReceived) {\n                            throw \"extra message\";\n                        }\n                        yield yield __await(parse(data));\n                    }\n                    // Node wil not throw an AbortError on `read` if the\n                    // signal is aborted before `getReader` is called.\n                    // As a work around we check at the end and throw.\n                    //\n                    // Ref: https://github.com/nodejs/undici/issues/1940\n                    if (\"throwIfAborted\" in signal) {\n                        // We assume that implementations without `throwIfAborted` (old\n                        // browsers) do honor aborted signals on `read`.\n                        signal.throwIfAborted();\n                    }\n                    if (!trailerReceived) {\n                        throw \"missing trailer\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.methodKind != \"server_streaming\") {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return encodeEnvelope(0, serialize(r.value));\n            }\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return runStreamingCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: true,\n                    service: method.parent,\n                    method,\n                    requestMethod: \"POST\",\n                    url: createMethodUrl(options.baseUrl, method),\n                    header: requestHeader(useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    const { foundStatus, headerError } = validateResponse(fRes.status, fRes.headers);\n                    if (headerError != undefined) {\n                        throw headerError;\n                    }\n                    if (!fRes.body) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, foundStatus, trailer, fRes.headers, req.signal) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": ["_a", "header", "signal", "input", "requestHeader", "codeFromHttpStatus", "validateResponse", "codeFromHttpStatus", "__await", "__asyncGenerator", "fetchOptions", "requestHeader", "_a", "validateResponse", "message", "header", "signal", "input"]
}
